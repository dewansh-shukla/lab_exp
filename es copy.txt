PROGRAM 1:

 Figure: Usage of internal UART
#include <LPC17xx.h>
void delay(unsigned int r1);
void UART0_Init(void);
unsignedinti ;
unsigned char *ptr, arr[] = "Hello World\r";
#define THR_EMPTY 0x20 //U0THR is Empty
int main(void)
{
UART0_Init();
while(1)
{
ptr = arr;
while ( *ptr != '\0')
{
while ((LPC_UART0->LSR & THR_EMPTY) != THR_EMPTY) ;
// if LSR 5th bit = 0 wait for data
 // if LSR 5th bit=1 THR has valid data to be transmitted.
//Is U0THR is EMPTY??
LPC_UART0->THR = *ptr++;
}
for(i=0;i<=60000;i++); // delay
}
}
void UART0_Init(void)
{
LPC_SC->PCONP |= 0x00000008; //UART0 peripheral enable
LPC_PINCON->PINSEL0 = 0x00000050; //P0.2 used as TxD0, P0.3 used as RxD0
LPC_UART0->LCR = 0x00000083; //enable divisor latch, parity disable,
 //1 stop bit, 8 bit word length
LPC_UART0->DLM = 0X00;
LPC_UART0->DLL = 0x1A; //select baud rate 9600 bps for 4 MHz
LPC_UART0->LCR = 0X00000003; //Disable divisor latch
LPC_UART0->FCR = 0x07; //FIFO enable, RX FIFO reset, TX FIFO reset
}
RESULT:LPC1768 ARM microcontroller is programmed to interface microcontroller and PC using
UART. A message “Hello world” is transmitted from the microcontroller using UART interface. The
message is received in the PC and displayed in a command window.
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 40
PROGRAM 2:
Interface and control a DC motor
A DC motor is an Electrical machine which converts Electrical energy into Mechanical energy. It
works on the principle that whenever a current carrying conductor is placed in a magnetic field, it
experiences a mechanical force.
DC (direct current) motor rotates continuously. It has two terminals positive and negative.
Connecting DC power supply to these terminals rotates motor in one direction and reversing the
polarity of the power supply reverses the direction of rotation.
/***********************************************************************************
DC MOTOR CONTROL USING ON CHIP PWM
Controller: LPC1768
Description:
Port line P1.24 is used for the PWM feature. When T0TC matches the MR0 counts interrupt is generated
and Duty cycle will be changed. Depends upon the Duty cycle Motor speed also changes.
PWM 1.5 is used. Match register 0 is used for count purpose.
PWM 1 match register 5 is incremented or decremented at each interrupted
*************************************************************************************/
SPEED CONTROL OF DC MOTOR
#include <lpc17xx.h>
voidpwm_init(void);
void PWM1_IRQHandler(void);
unsigned long int i;
unsigned char flag,flag1;
int main(void)
{
SystemInit();
SystemCoreClockUpdate();
pwm_init();
while(1){
for(i=0;i<=1000;i++); // delay
}//end of while
}//end of main
voidpwm_init(void)
{
LPC_SC->PCONP = (1<<6); //PWM1 is powered
LPC_PINCON->PINSEL3 = 0x00020000; //pwm1.5 is selected for the pin P1.24
LPC_PWM1->PR = 0x00000000; //Count frequency : Fpclk
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 41
LPC_PWM1->PCR = 0x0002000; //select PWM5 single edge and PWM5 output is enabled
LPC_PWM1->MCR = 0x00000003; //Reset and interrupt on PWMMR0
LPC_PWM1->MR0 = 60000; //setup match register 0 count
LPC_PWM1->MR5 = 0x00000100; //setup match register MR5
LPC_PWM1->LER = 0x000000FF; //enable shadow copy register
LPC_PWM1->TCR = 0x00000002; //RESET COUNTER AND PRESCALER
LPC_PWM1->TCR = 0x00000009; //enable PWM and counter
NVIC_EnableIRQ (PWM1_IRQn);
return;
}
void PWM1_IRQHandler(void)
{
LPC_PWM1->IR = 0xff; //clear the interrupts
if(flag == 0x00)
 {
LPC_PWM1->MR5 += 100;
LPC_PWM1->LER = 0x000000FF;
if(LPC_PWM1->MR5 >= 57000) //for 10% of duty cycle MR5=3000,
//for 50%, MR5=15000, for 90% MR5= 27000 {
flag1 = 0xff;
flag = 0xff;
LPC_PWM1->LER = 0x000000fF;
}
for(i=0;i<8000;i++);
}
else if(flag1 == 0xff)
 {
LPC_PWM1->MR5 -= 100;
LPC_PWM1->LER = 0x000000FF;
if(LPC_PWM1->MR5 <= 0x300) //1% of duty cycle MR5=300
{
flag = 0x00;
flag1 = 0x00;
LPC_PWM1->LER = 0X000000fF;
}
for(i=0;i<8000;i++);
}
}
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 42
DIRECTION CONTROL OF DC MOTOR
/************************************************************************************
Description:
Direction of the DCM is controlled in this software by alternatively interchanging the supply with the help
of Relay.
Port lines: P1.24 and P0.26.
Port line P1.24 used for the PWM feature. When T0TC matches the MR0 counts interrupt is generated and
duty cycle will be changed. Depends upon the Duty cycle Motor speed also changes.
PWM 1.5 is used. Match register 0 is used for count purpose.
PWM 1 match register is incremented or decremented at each interrupted.
************************************************************************************/
#include <LPC17xx.H>
voidClock_Wise(void);
voidAClock_Wise(void);
unsigned long i;
int main(void)
{
LPC_PINCON->PINSEL1 = 0x00000000; //P0.26 GPIO, P0.26 controls direction
LPC_PINCON->PINSEL3 = 0x00000000; //P1.24 GPIO
LPC_GPIO0->FIODIR |= 0x04000000; //P0.26 output
LPC_GPIO1->FIODIR |= 0x01000000; //P1.24 output
while(1)
{
Clock_Wise();
for(i=0;i<300000;i++);
AClock_Wise();
for(i=0;i<300000;i++);
} //end while(1)
} //end main
voidClock_Wise(void)
{
LPC_GPIO1->FIOCLR = 0x01000000; //P1.24 Kept low to off DCM
for(i=0;i<10000;i++); //delay to compensate inertia
LPC_GPIO0->FIOSET = 0x04000000; //coil is on
LPC_GPIO1->FIOSET = 0x01000000; //motor in on
} //end void Clock_Wise(void)
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 43
voidAClock_Wise(void)
{
LPC_GPIO1->FIOCLR = 0x01000000; //P1.24 Kept low to off DCM
for(i=0;i<10000;i++); //delay to componsate inertia
LPC_GPIO0->FIOCLR = 0x04000000; //coil is off
LPC_GPIO1->FIOSET = 0x01000000; //Motor is on
} //end void AClock_Wise(void)
RESULT: LPC1768 ARM microcontroller is programmed to interface and control a DC motor.
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 44
PROGRAM 3:
Interface a stepper motor and rotate it in clockwise and anti-clockwise direction
A stepper motor (also referred to as step or stepping motor) is an electromechanical device
achieving mechanical movements through conversion of electrical pulses. Stepping motors can be
viewed as electric motors without commutators. Typically, all winding in the motor are part of the
stator, and the rotor is either a permanent magnet or, in the case of variable reluctance motors, a
toothed block of some magnetically soft material. All of the commutation must be handled
externally by the motor controller, and typically, the motors and controllers are designed so that the
motor may be held in any fixed position as well as being rotated one way or the other.
Stepper motors are driven by digital pulses rather than by a continuous applied voltage. Unlike
conventional electric motors which rotate continuously, stepper motors rotate or step in fixed
angular increments. A stepper motor is most commonly used for position control. With a stepper
motor/driver/controller system design, it is assumed the stepper motor will follow digital
instructions. Most steppers can be stepped at audio frequencies, allowing them to spin quite quickly,
and with an appropriate controller, they may be started and stopped at controlled orientations.
In this lab, we’ll use a so called “five wire stepper” shown in the figure below. This 28BYJ48
stepper motor is driven via a driver board that contains 4 Darlington drivers (ULN2003) and 4
LEDs.
PM1 – it's a 5 pin straight male power mate.
A stepper motor direction is controlled by shifting the voltage across the coils. Port lines: P2.0 to
P2.3.
/******************************************************************************
Stepper motor Direction control
Controller: LPC1768
Description: A stepper motor direction is controlled by shifting the voltage across the coils.
Port lines: P2.0 to P2.3.
******************************************************************************/
0 0 0 0 0 0 0 0
FIODIR By default all bits are zero
Direction: 0001 1
 0010 2
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 45
 0100 4
 1000 8
PINSEL: Each Port has 2 PINSEL Registers
Port 2 [ PINSEL4 P2.0 –P2.15
[ PINSEL5 P2.16 – P2.31
For this program, we use PINSEL4 (Since P2.0 – P2.3 is required)
By default, PINSEL4 is 0xFFFFFFFF
#include <LPC17xx.H>
voidclock_wise(void);
voidanti_clock_wise(void);
unsigned long int var1,var2;
unsignedinti=0,j=0,k=0;
int main(void)
{
LPC_PINCON->PINSEL4 = 0x00000000; //P2.0 to P2.3 GPIO
LPC_GPIO2->FIODIR = 0x0000000F; //P2.0 to P2.3 output
while(1)
{
for(j=0;j<50;j++) //50 times in Clock wise Rotation
clock_wise();
for(k=0;k<65000;k++); //Delay to show Anti-clock Rotation
for(j=0;j<50;j++) /50 times in Anti-clock wise Rotation
anti_clock_wise();
for(k=0;k<65000;k++); //Delay to show clock Rotation
}
//End of while(1)
} //End of main
voidclock_wise(void)
{
 var1 = 0x00000001; //For Clockwise
for(i=0;i<=3;i++) //for A B C D Stepping
{
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 46
 LPC_GPIO2->FIOCLR = 0X0000000F;
 LPC_GPIO2->FIOSET = var1;
 var1 = var1<<1; //For Clockwise
for(k=0;k<3000;k++); //for step speed variation
 }
}
voidanti_clock_wise(void)
{
var1 = 0x0000008; //For Anticlockwise
for(i=0;i<=3;i++) //for A B C D Stepping
 {
LPC_GPIO2->FIOCLR = 0X0000000F;
LPC_GPIO2->FIOSET = var1;
var1 = var1>>1; //For Anticlockwise
for(k=0;k<3000;k++); //for step speed variation
 }
}
RESULT:LPC1768 ARM microcontroller is programmed to interface a stepper motor. Stepper motor is
rotated in both clockwise and anti-clockwise direction. The direction of rotation in the motor is changed
after a certain delay.
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 47
PROGRAM 5:
Interface a DAC and generate Triangular and Square waveforms Square Waveform
/************************************************************************************
External DAC interface (Square Wave)
Controller: LPC1768
Description: This example explains about how Square Wave is generated.
P0.4 to P0.11 are used to get the Digital values.
************************************************************************************/
PINSEL0
0000 0000 0000 0000 0000 0000 0000 0000
0 0 0 0 0 0 0 0
GPIO0->FIODIR
0000 0000 0000 0000 0000 1111 1111 0000
0 0 0 0 0 F F 0
FIOMASK
1111 1111 1111 1111 1111 0000 0000 1111
0 0 0 0 0 F F 0
#include <LPC17xx.H>
void delay(void);
int main ()
{
LPC_PINCON->PINSEL0 = 0x00000000; // Configure P0.4 to P0.11 as GPIO
LPC_GPIO0->FIODIR = 0x00000FF0 ; // Configure P0.4 to P0.11 as Output
LPC_GPIO0->FIOMASK = 0XFFFFF00F;
while(1)
{
 LPC_GPIO0->FIOSET = 0x00000FF0 ;
delay();
 LPC_GPIO0->FIOCLR = 0x00000FF0 ;
delay();
 }
}
void delay(void)
{
unsignedinti=0;
for(i=0;i<=9500;i++);
}
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 48
Triangular Waveform
/************************************************************************************
External DAC interface (Triangular Waveform)
Controller: LPC1768
Description: This example explains about how Triangular Wave is generated.
P0.4 to P0.11 are used to get the Digital values.
************************************************************************************/
#include <LPC17xx.H>
int main ()
{
unsigned long int temp=0x00000000;
unsignedinti=0;
LPC_PINCON->PINSEL0 = 0x00000000; // Configure P0.4 to P0.11 as GPIO
LPC_GPIO0->FIODIR = 0x00000FF0 ; // Configure P0.4 to P0.11 as Outputs
LPC_GPIO0->FIOMASK = 0XFFFFF00F;
while(1)
{
for(i=0;i!=0xFF;i++) /*output 0 to FE*/
{
temp=i;
temp = temp << 4;
LPC_GPIO0->FIOPIN = temp;
}
for(i=0xFF; i!=0;i--) /* output FF to 1*/
{
temp=i;
temp = temp << 4;
LPC_GPIO0->FIOPIN = temp;
 }
}//End of while(1)
}//End of main()
RESULT:LPC1768 - ARM CORTEX M3 microcontroller is programmed to generate waveforms using
DAC. DAC is interfaced with the microcontroller and the output is observed on CRO, CRO is connected to
the output pin of DAC. The digital value is converted into analog value using DAC and displayed on CRO.
The amplitude and frequency of generated triangular wave are __________ Volts and _______ Hertz,
respectively. The amplitude and frequency of generated square wave are __________ Volts and _______
Hertz, respectively.
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 49
PROGRAM 5:
Interface a 4x4 keyboard and display the key code on an LCD
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 50
#include <LPC17xx.h>
#include "lcd.h"
void scan(void);
unsigned char col,row,var,flag,key,*ptr;
unsigned long int i,var1,temp,temp3;
unsigned char SCAN_CODE[16] = {0x1E,0x1D,0x1B,0x17,
0x2E,0x2D,0x2B,0x27,
0x4E,0x4D,0x4B,0x47,
0x8E,0x8D,0x8B,0x87};
unsigned char ASCII_CODE[16] = {'0','1','2','3',
 '4','5','6','7',
 '8','9','A','B',
 'C','D','E','F'};
int main(void)
{
LPC_PINCON->PINSEL3 = 0x00000000; //P1.20 to P1.23 MADE GPIO
LPC_PINCON->PINSEL0 = 0x00000000; //P0.15 as GPIO
LPC_PINCON->PINSEL1 = 0x00000000; //P0.16 t0 P0.18 made GPIO
LPC_GPIO0->FIODIR &= ~0x00078000; //made INput P0.15 to P0.18 (cols)
LPC_GPIO1->FIODIR |= 0x00F00000; //made output P1.20 to P1.23 (rows)
LPC_GPIO1->FIOSET = 0x00F00000;
lcd_init();
while(1)
{
while(1)
{
for(row=1;row<5;row++)
{
if(row == 1)
var1 = 0x00100000;
else if(row == 2)
var1 = 0x00200000;
else if(row == 3)
var1 = 0x00400000;
else if(row == 4)
var1 = 0x00800000;
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 51
temp = var1;
LPC_GPIO1->FIOSET = 0x00F00000;
LPC_GPIO1->FIOCLR = var1;
flag = 0;
scan();
if(flag == 1)
break;
}
//end for(row=1;row<5;row++)
if(flag == 1)
break;
}
//2nd while(1)
for(i=0;i<16;i++)
{
if(key == SCAN_CODE[i])
{
key = ASCII_CODE[i];
break;
}
//end if(key == SCAN_CODE[i])
}
//end for(i=0;i<16;i++)
temp1 = 0x80;
lcd_com();
delay_lcd(800);
lcd_puts(&key);
}
//end while 1
}
//end main
void scan(void)
{
unsigned long temp3;
temp3 = LPC_GPIO0->FIOPIN;
temp3 &= 0x00078000;
if(temp3 != 0x00078000)
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 52
{
flag = 1;
temp3 >>= 15; //Shifted to come at LN of byte
temp>>= 16; //shifted to come at HN of byte
key = temp3|temp;
}
//1st if(temp3 != 0x00000000)
}
//end scan
RESULT: LPC1768 ARM microcontroller is programmed to interface a 4x4 keyboard. The key press is
captured through the interface and the value of pressed key is computed in the program. Then, the key value
or code is displayed on an LCD screen.
PROGRAM 6:
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 53
Demonstrate the use of an external interrupt to toggle an LED On/ Off
#include <LPC17xx.h>
void EINT3_IRQHandler(void);
unsigned char int3_flag=0;
unsignedint z;
int main(void)
{
LPC_PINCON->PINSEL4 = 0x04000000; //P2.13 as EINT3
LPC_GPIO2->FIODIR = 0x00001000; //P2.12 is assigned output
LPC_GPIO2->FIOSET = 0x00001000; //Initial LED is kept on
LPC_SC->EXTINT = 0x00000008; //writing 1 clears the interrupt, get set if there is interrupt
LPC_SC->EXTMODE = 0x00000008;//EINT3 is initiated as edge sensitive, 0 for level sensitive
LPC_SC->EXTPOLAR = 0x00000000; //EINT3 is falling edge sensitive, 1 for rising edge
//above registers, bit0-EINT0, bit1-EINT1, bit2-EINT2,bit3-EINT3
NVIC_EnableIRQ(EINT3_IRQn); //core_cm3.h
while(1) ;
}
void EINT3_IRQHandler(void)
{
LPC_SC->EXTINT = 0x00000008; //cleares the interrupt
if(int3_flag == 0x00) //when flag is '0' off the LED
{
LPC_GPIO2->FIOCLR = 0x00001000;
for(z=0;z<=300000;z++);
int3_flag = 0xff;
}
else //when flag is FF on the LED
{
LPC_GPIO2->FIOSET = 0x00001000;
for(z=0;z<=300000;z++);
int3_flag = 0;
}
}
RESULT: LPC1768 ARM microcontroller is programmed to interface an external interrupt to toggle an
LED On/ Off. The external interrupt is generated using a push button. When the push button is pressed, the
LED which is in ‘Off’ state will turn ‘On’ and vice-versa
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 54
PROGRAM 7:
Display the Hex digits 0 to F on a 7-segment LED interface, with an appropriate delay
in between
/************************************************************************
SEVEN SEGMENT DISPLAY
Controller: LPC1768
Description: DISPLAYS ARE CONNECTED IN COMMON CATHODE MODE
Port0 Connected to data lines of all 7 segment displays
*************************************************************************
a
 ----
f| g |b
|----|
e| |c
 ---- . dot
d
a = P0.04
b = P0.05
c = P0.06
d = P0.07
e = P0.08
f = P0.09
g = P0.10
dot = P0.11
Select lines for two 7 Segments
DIS1 P0.19
DIS2 P0.20
************************************************************************************/
GPIO0
20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1 1 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0
1 8 0 f f 0
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 55
Figure: common cathode display (to glow particular segment pass logic 1)
Table: hexadecimal equivalent values for each digit to be displayed
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 56
#include <LPC17xx.h>
Unsigned intdelay, Switchcount=0,j;
unsigned intDisp[16] = {0x000003f0, 0x00000060, 0x000005b0, 0x000004f0, 0x00000660,
0x000006d0,0x000007d0, 0x00000070, 0x000007f0, 0x000006f0, 0x00000770,0x000007c0,
0x00000390, 0x000005e0, 0x00000790, 0x00000710 };
#define ALLDISP 0x00180000 //Select all display
#define DATAPORT 0x00000ff0 //P0.4 to P0.11 : Data lines connected to drive Seven Segments
int main (void)
{
LPC_PINCON->PINSEL0 = 0x00000000;
LPC_PINCON->PINSEL1 = 0x00000000;
LPC_GPIO0->FIODIR = 0x00180ff0;
while(1)
{
LPC_GPIO0->FIOSET |= 0x00100000;
LPC_GPIO0->FIOCLR =0x00000ff0; // clear the data lines to 7-segment displays
LPC_GPIO0->FIOSET = Disp[Switchcount]; // get the 7-segment display value from the array
for(j=0;j<3;j++)
for(delay=0;delay<30000;delay++); // delay
Switchcount++;
if(Switchcount == 0x10) // 0 to F has been displayed ? go back to 0
{
Switchcount = 0;
 LPC_GPIO0->FIOCLR = 0x00180ff0;
}
}
}
RESULT: LPC1768 ARM microcontroller is programmed to display hexadecimal digits on 7-segment
LED. The equivalent code for displaying hexadecimal digits is stored in the program. The code is provided
as input to the LED to display an hexadecimal digit. The displayed digit is changed after a delay and all the
hexadecimal digits are displayed repetitively.
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 57
PROGRAM 8:
Measure Ambient temperature using a sensor and SPI ADC IC
#include <LPC17xx.h>
#include <stdio.h>
#include "UART0.h"
#include "SPI.h"
#define VREF 5280
#define FULLSCALE 4095
#define SSEL 0x00010000
unsigned char temp1=0x00;
unsignedint up4bits,low8bits;
unsigned char *ptr,*ptr1,adc_val[8],temp_float[12];
unsigned char temp_op[]= "TEMP('C)=";
floatanalog_val,temp_valK,temp_valC;
volatile unsigned long i=0,j = 0;
unsignedintavg;
int main(void)
{
LPC_GPIO0->FIODIR |= SSEL; //CHIPSELECT LINE MADE AS O/P P0.7
LPC_GPIO0->FIOSET = SSEL; //if device is powered up with CS low, set high before comm
UART0_Init(); //Initializes UART0
SPI_Init(); //Initializes SPI
spi_flag=0;
while(1)
{
for(i=0;i<8;i++)
{
LPC_GPIO0->FIOCLR = SSEL; //make SS low
for(j=0;j<1000;j++);
LPC_SPI->SPDR = 0x01; //Send the start bit
while(spi_flag == 0);
spi_flag = 0;
LPC_SPI->SPDR = 0xC0; //Select channel in single ended mode & MSB first format
while(spi_flag == 0);
spi_flag = 0;
up4bits = temp; //temp has SPI data register value
LPC_SPI->SPDR = 0x00;
while(spi_flag == 0);
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 58
spi_flag = 0;
low8bits = temp; //SPI Data Register.
up4bits = (up4bits & 0x0f)<<8;
low8bits|=up4bits; //combine the lower bits and upper bits
avg += low8bits;
LPC_GPIO0->FIOSET = SSEL; //make SS high
for(j=0;j<1000;j++);
}
avg>>= 3;
analog_val = (float) ( avg * (float)VREF)/(float)FULLSCALE ;
temp_valK = (float)( (analog_val * 273.14)/(2731.4)); //temperature in deg K
temp_valC = temp_valK - 273.14; //temperature in deg C
sprintf(temp_float,"%3.2f",temp_valC);
avg = 0x00;
ptr = temp_op;
while(*ptr!='\0')
 {
LPC_UART0->THR = *ptr++;
while(tx0_flag == 0);
tx0_flag= 0;
for(i=0;i<200;i++);
}
ptr1 = temp_float;
while(*ptr1!='\0')
 {
LPC_UART0->THR = *ptr1++;
while(tx0_flag == 0);
tx0_flag= 0;
for(i=0;i<200;i++);
}
for(j=0;j<65000;j++); //delay for display // for 1 sec value 400000//for 10000 counts 25msec.
LPC_UART0->THR = 0x0D; //new line
while(tx0_flag == 0);
tx0_flag= 0;
 }
}
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 59
SPI INTERFACE
#include <LPC17xx.h>
#include "SPI.h"
unsigned char spi_flag = 0, temp=0;
voidSPI_Init(void)
{
LPC_PINCON->PINSEL0 |= 0xC0000000; //P0.15 as SCK
LPC_PINCON->PINSEL1 = 0x0000003C; //select MISO-P0.17,MOSI-P0.18
LPC_SPI->SPCCR = 0x1E; // SPI CLOCK SELECTED AS 100KHZ
LPC_SPI->SPCR = 0xA0; //8 bit data, actve high clk, master SPI mode,SPIInt enable
 // Master mode and SCK line is active high
LPC_SPI->SPINT = 0x01; //clear the interrupt flag
NVIC_EnableIRQ(SPI_IRQn);
}
voidSPI_IRQHandler(void)
{
spi_flag = 1;
temp = LPC_SPI->SPSR; // To clear SPIF bit we have to read status register.
temp = LPC_SPI->SPDR; // Then read the data register(optional)
 LPC_SPI->SPINT = 0x01; // To clear the SPI interrupt
}
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 60
UART INTERFACE
#include <LPC17xx.h>
#include "uart0.h"
unsigned char recv_buf[50], recv_data=0, recv_index=0;
unsigned char rx0_flag=0, tx0_flag=0;
void UART0_Init(void)
{
LPC_SC->PCONP |= 0x00000008; //UART0 peripheral enable
LPC_PINCON->PINSEL0 &= ~0x000000F0;
LPC_PINCON->PINSEL0 |= 0x00000050;
LPC_UART0->LCR = 0x00000083; //enable divisor latch, parity disable, 1 stop bit, 8bit word
length
LPC_UART0->DLM = 0X00;
LPC_UART0->DLL = 0x1A; //select baud rate 9600 bps
LPC_UART0->LCR = 0X00000003;
LPC_UART0->FCR = 0x07;
LPC_UART0->IER = 0X03; //select Transmit and receive interrupt
NVIC_EnableIRQ(UART0_IRQn); //Assigning channel
}
void UART0_IRQHandler(void)
{
unsigned long Int_Stat;
Int_Stat = LPC_UART0->IIR; //reading the data from interrupt identification register
Int_Stat = Int_Stat& 0x06; //masking other than txmitint&rcve data indicator
if((Int_Stat& 0x02)== 0x02) //transmit interrupt
tx0_flag = 0xff;
else if( (Int_Stat& 0x04) == 0x04) //recve data availble
{
recv_data = LPC_UART0->RBR;
rx0_flag = 0xff;
}
}
Result:LPC1768 ARM microcontroller is programmed to record the room’s ambient temperature using
temperature sensor. The temperature obtained from the sensor is converted into a digital value using SPI
ADC.
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 61
PART A:
ALP to multiply two 16 bit binary numbers.
Program:
;/* PROGRAM TO MULTIPLY TWO 16BIT NUMBERS
*/
;/* VALUE1: 1900H (6400) (IN R1)
*/
;/* VALUE2: 0C80H(3200) (IN R2)
*/
;/* RESULT: 1388000H(20480000)(IN R3)
*/
;/* SET A BREAKPOINT AT NOP INSTRUCTION,RUN THE PROGRAM & CHECK THE
RESULT */
;/* PROGRAM WRITTEN BY ALS R&D TEAM BENGALURU DATE:08/08/2011
*/
AREA MULTIPLY , CODE, READONLY
EXPORT __main
__main
ENTRY ;Mark first instruction to execute
START
MOV r1,#6400 ; STORE FIRST NUMBER IN R0
MOV r2,#3200 ; STORE SECOND NUMBER IN R1
MUL r3,r1,r2 ; MULTIPLICATION
NOP
NOP
NOP
END ;Mark end of file
Embedded Systems Lab 18ECL66
Dept of ECE, DSATM, BANGALORE-82Page 62
2. ALP to find the sum of first 10 integer numbers.
;/* PROGRAM TO FIND THE SUM OF FIRST 10 INTEGER NUMBER
*/
;/* In this example we have taken n=10
*/
;/* Check the result in R0/R3 register =37H (55) */
;/* SET A BREAKPOINT AT NOP INSTRUCTION,RUN THE PROGRAM & CHECK THE
RESULT */
;/* PROGRAM WRITTEN BY ALS R&D TEAM BENGALURU DATE:08/08/2011
*/
AREA ADD1to10, CODE, READONLY
EXPORT __main
__main
MOV r0, #10 ; STORE SUM NUMBER IN R0
MOV r1,r0 ; MOVE THE SAME NUMBER IN R1
rpt
SUBS r1, r1, #1 ; SUBTRACTION
CMP r1, #0 ; COMPARISON
BEQ STOP
ADD r3,r0,r1; ; ADDITION
MOV r0,r3 ; Result
BNE rpt ; BRANCH TO THE LOOP IF NOT EQUAL
STOP
NOP
NOP
NOP
END ;Mark end of file
Embedded S