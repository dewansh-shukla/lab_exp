QPSk transmitter and reciever


clc;
clearall;
closeall;


data=[0  1 0 1 1 1 0 0 1 1]; 

figure(1)
stem(data, 'linewidth',3), grid on;
title('  Transmitted data ');
axis([ 0 11 0 1.5]);

data_NZR=2*data-1; 
s_p_data=reshape(data_NZR,2,length(data)/2); 

br=10.^6;
f=br; 
T=1/br; 
t=T/99:T/99:T; 

% QPSK modulation
y=[];
y_in=[];
y_qd=[];
for(i=1:length(data)/2)
    y1=s_p_data(1,i)*cos(2*pi*f*t); 
    y2=s_p_data(2,i)*sin(2*pi*f*t) ;
y_in=[y_in y1]; 
y_qd=[y_qd y2]; 
    y=[y y1+y2]; 
end
Tx_sig=y; 
tt=T/99:T/99:(T*length(data))/2;

figure(2)
subplot(3,1,1);
plot(tt,y_in,'linewidth',3), grid on;
title(' wave form for inphase component in QPSK modulation ');
xlabel('time(sec)');
ylabel(' amplitude(volt0');

subplot(3,1,2);
plot(tt,y_qd,'linewidth',3), grid on;
title(' wave form for Quadrature component in QPSK modulation ');
xlabel('time(sec)');
ylabel(' amplitude(volt0');


subplot(3,1,3);
plot(tt,Tx_sig,'r','linewidth',3), grid on;
title('QPSK modulated signal (sum of inphase and Quadrature phase signal)');
xlabel('time(sec)');
ylabel(' amplitude(volt0');

% QPSK demodulation
Rx_data=[];
Rx_sig=Tx_sig; % Received signal
for(i=1:1:length(data)/2)
% inphase coherent detector 
Z_in=Rx_sig((i-1)*length(t)+1:i*length(t)).*cos(2*pi*f*t); 
Z_in_intg=(trapz(t,Z_in))*(2/T);
if(Z_in_intg>0) % Decision
Rx_in_data=1;
else
Rx_in_data=0; 
end
% Quadrature coherent detector
Z_qd=Rx_sig((i-1)*length(t)+1:i*length(t)).*sin(2*pi*f*t);

Z_qd_intg=(trapz(t,Z_qd))*(2/T);%integration using trapizodial rule
if (Z_qd_intg>0)% Decision
Rx_qd_data=1;
else
Rx_qd_data=0; 
end
Rx_data=[Rx_dataRx_in_dataRx_qd_data];
end
figure(3)
stem(Rx_data,'linewidth',3) 
title(' Received data ');
axis([ 0 11 0 1.5]), grid on;




DPSK Signal

clc;
clearall;
closeall;
% Input data
N = 1e6;
EbN0dB = 0:2:16; 
M = 2;
% Constellation 2-DPSK
refArray = [ 1.0000 + 0.0000i 0.0000 + 1.0000i -1.0000 + 0.0000i -0.0000 - 1.0000i];
symErrSimulated = zeros(1,length(EbN0dB));
k = log2(M);
EsN0dB = EbN0dB + 10*log10(k);
data = 2*ceil(M.*rand(N,1))-1;
data_diff = filter(1,[1 -1],data);
s = refArray(mod(data_diff,2*M)+1);
index =1;
for x = EsN0dB,
noiseVariance = 1/(10.^(x/10));%Standard deviation for AWGN Noise
noiseSigma = sqrt(noiseVariance/2);
noise = noiseSigma*(randn(1,N)+1i*randn(1,N));
received = s + noise; % additive white gaussian noise
estPhase = angle(received);
est_diffPhase = filter([1 -1],1,estPhase)*M/pi;
y = mod(2*floor(est_diffPhase/2)+1,2*M); % quantizing
symErrSimulated(1,index) = sum(y~=data')/(N*k);
index=index+1;
end
EbN0lin = 10.^(EbN0dB/10);
symErrTheory = 0.5*exp(-EbN0lin);
figure;
semilogy(EbN0dB,symErrTheory,'b','LineWidth',1.5);hold on;
semilogy(EbN0dB,symErrSimulated,'r*','LineWidth',1.5);hold on;
legend({'Theory','Simulated'})
gridon;
xlabel('Eb/N0(dB)');
ylabel('Bit Error Rate (Pb)');
title('Simulation BER vs. Theoretical BER for Binary DPSK');







